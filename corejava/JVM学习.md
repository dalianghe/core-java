# JVM学习

### JVM相关概念
![](http://i.imgur.com/BjS0UG6.png)
### 内存结构

	程序计数器
		当前线程所执行的字节码的行号指示器（线程私有）。
		如果线程正在执行的是一个java方法，计数器记录的是正在执行的虚拟机字节码的地址；如果线程正在执行的是Native方法，计数器的值为空（Undefind）。
		此区域是java虚拟机规范中唯一没有规定任何OutOfMemoryError情况的区域。
		
	JVM虚拟机栈	
		虚拟机栈描述的java方法执行的内存模型（线程私有），每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
		局部变量表存放编译期可知的各种基本数据类型、引用类型和returnAddress类型。
		局部变量表所需的内存空间在编译期完成分配。
		java虚拟机规范，对该区域规定了两种异常状况：
		1、线程请求的深度大于虚拟机所允许的深度，抛出StackOverflowError异常；
		2、如果扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。

	本地方法栈
		与虚拟机栈作用相似，区别是虚拟机栈为虚拟机执行java方法服务，本地方法栈为虚拟机使用到的Native方法服务。
		虚拟机规范没有强制规定本地方法栈中方法使用的语音、使用方式与数据结构，具体虚拟机可自由实现。
		异常与虚拟机栈相同有两种：
		1、StackOverflowError
		2、OutOfMemoryError

	方法区
		线程共享、用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
		该区域内存回收目标主要是针对常量池的回收和类型的卸载。
		java虚拟机规定，方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。
	
	运行时常量池
		方法区的一部分，存放Class文件常量池中编译期生成的各种字面量和符合引用，在类加载后进入方法区的运行时常量池中。
		虚拟机规范未规定任何细节要求，提供商可自行实现。
		运行时常量池相对于Class文件常量池的一个重要特征是具备动态性，即java语言未要求常量必须在编译期产生，运行期间也可能将新的常量放入池中。
		无法再申请内存时抛出OutOfMemoryError异常。

	java堆
		java虚拟机管理内存的最大一块，所有线程共享，虚拟机启动创建，存放对象实例的一块内存空间。
		从内存回收的角度，堆可分为：新生代和老年代，再细化一点有Eden区、From Survivor和To Survivor等。
		从内存分配的角度，线程共享的java堆，可划分出多个线程私有的本地内存分配缓存（Thread Local Allocation Buffer）TLAB。
		虚拟机规范规定，java堆可以处在物理上不连续的内存空间，只要逻辑上连续即可。
		通过参数 -Xmx和-Xms控制。
		内存空间无法完成分配，并且无法扩展时，抛出OutOfMemoryError异常。

### 对象的创建、布局和访问

对象创建
	
	虚拟机遇到new指令，首先检查指令的参数是否能在常量池中定位一个类的符号引用，并检查这个符号引用代表的类是否已加载、解析和初始化，如果没有，必须先进行类的加载。
	类加载完成后，接着就是为新生对象分配内存空间。两种方法：
	1、指针碰撞
	2、空闲列表
	采用哪种方式取决于内存是否规整，内存是否规整取决于采取的内存回收器是否具有压缩整理机制。

对象布局

	在HotSpot虚拟机中，对象在内存中布局分为：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
	一、对象头
	对象头存储两部分数据：
	1、存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志等，此部分数据在32位和64位虚拟机中分别为32bit和64bit，官方称它为“Mark Word”；
	2、存储对象指针，即对象指向它的类元数据的指针，虚拟机通过此指针确定此对象属于哪个类的实例。
	注：如果对象是数组，对象头中还需记录数组长度数据，虚拟机可通过普通的java对象元数据确定java对象大小，但从数组的元数据无法确定数组大小。
	二、实例数据
	对象真正存储的有效信息，即程序代码中所定义的各种类型的字段内容。
	存储顺序受虚拟机分配策略参数（FieldsAllocationStyle）和字段在java源码中定义顺序影响。
	三、对齐填充
	仅起占位符作用，不必然且无特殊含义。
	HotSpot VM内存管理系统要求对象大小必须是8字节的整数倍，对象头部分正好是8字节的倍数，因此，当对象实例数据没有对齐是，需要通过对齐补充来补全。

对象访问

	java程序通过虚拟机栈（局部变量表）上的reference来操作堆上的对象。
	虚拟机规范只规定了reference类型指向对象的引用，未定义引用通过何种方式定位、访问堆中对象的具体位置，取决于虚拟机实现，目前主流的访问方式有两种：
	1、句柄方式
	在java堆中划分出一块内存作为句柄池，reference中存储的是对象句柄地址，句柄中包括对象实例数据和类型数据各自的具体地址信息。
	![](http://i.imgur.com/xJN8ASM.png)
	2、直接引用
	

### 类加载机制

### 垃圾收集

