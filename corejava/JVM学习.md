# JVM学习

### JVM相关概念
![](http://i.imgur.com/BjS0UG6.png)
### 内存结构

	程序计数器
		当前线程所执行的字节码的行号指示器（线程私有）。
		如果线程正在执行的是一个java方法，计数器记录的是正在执行的虚拟机字节码的地址；如果线程正在执行的是Native方法，计数器的值为空（Undefind）。
		此区域是java虚拟机规范中唯一没有规定任何OutOfMemoryError情况的区域。
		
	JVM虚拟机栈	
		虚拟机栈描述的java方法执行的内存模型（线程私有），每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
		局部变量表存放编译期可知的各种基本数据类型、引用类型和returnAddress类型。
		局部变量表所需的内存空间在编译期完成分配。
		java虚拟机规范，对该区域规定了两种异常状况：
		1、线程请求的深度大于虚拟机所允许的深度，抛出StackOverflowError异常；
		2、如果扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。

	本地方法栈
		与虚拟机栈作用相似，区别是虚拟机栈为虚拟机执行java方法服务，本地方法栈为虚拟机使用到的Native方法服务。
		虚拟机规范没有强制规定本地方法栈中方法使用的语音、使用方式与数据结构，具体虚拟机可自由实现。
		异常与虚拟机栈相同有两种：
		1、StackOverflowError
		2、OutOfMemoryError

	方法区
		线程共享、用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
		该区域内存回收目标主要是针对常量池的回收和类型的卸载。
		java虚拟机规定，方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。
	
	运行时常量池
		方法区的一部分，存放Class文件常量池中编译期生成的各种字面量和符合引用，在类加载后进入方法区的运行时常量池中。
		虚拟机规范未规定任何细节要求，提供商可自行实现。
		运行时常量池相对于Class文件常量池的一个重要特征是具备动态性，即java语言未要求常量必须在编译期产生，运行期间也可能将新的常量放入池中。
		无法再申请内存时抛出OutOfMemoryError异常。

	java堆
		java虚拟机管理内存的最大一块，所有线程共享，虚拟机启动创建，存放对象实例的一块内存空间。
		从内存回收的角度，堆可分为：新生代和老年代，再细化一点有Eden区、From Survivor和To Survivor等。
		从内存分配的角度，线程共享的java堆，可划分出多个线程私有的本地内存分配缓存（Thread Local Allocation Buffer）TLAB。
		虚拟机规范规定，java堆可以处在物理上不连续的内存空间，只要逻辑上连续即可。
		通过参数 -Xmx和-Xms控制。
		内存空间无法完成分配，并且无法扩展时，抛出OutOfMemoryError异常。

### 类加载机制

### 垃圾收集

